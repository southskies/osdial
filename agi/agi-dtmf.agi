#!/usr/bin/perl
#
# agi-dtmf.agi - Parse in callerid and play dtmf files.
#
## Copyright (C) 2010  Lott Caskey  <lottcaskey@gmail.com>    LICENSE: AGPLv3
##
##     This file is part of OSDial.
##
##     OSDial is free software: you can redistribute it and/or modify
##     it under the terms of the GNU Affero General Public License as
##     published by the Free Software Foundation, either version 3 of
##     the License, or (at your option) any later version.
##
##     OSDial is distributed in the hope that it will be useful,
##     but WITHOUT ANY WARRANTY; without even the implied warranty of
##     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##     GNU Affero General Public License for more details.
##
##     You should have received a copy of the GNU Affero General Public
##     License along with OSDial.  If not, see <http://www.gnu.org/licenses/>.
##
# 
# This is a completed rewrite of the upstream agi-dtmf.agi.
#
#

$|++;

use strict;
use DBI;
use Time::HiRes ('gettimeofday','usleep','sleep');  # necessary to have perl sleep command of less than one second
use Asterisk::AGI;

my $AGI = new Asterisk::AGI;
my $vars = {};
my $server = {};

# Get OSD configuration directives.
$vars = getOSDconfig('/etc/osdial.conf');

$vars->{DB} = 0 unless ($vars->{DB});
$vars->{script} = 'agi-dtmf.agi';

$vars->{start_epoch} = time();
$vars->{start_date} = sql_date($vars->{start_epoch});
$vars->{AGILOGFILE} = $vars->{PATHlogs} . "/agiout." . $vars->{start_date};
$vars->{AGILOGFILE} =~ s/ .*//g;


# Connect to database.
my $dbhA = DBI->connect("DBI:mysql:" . $vars->{VARDB_database} . ":" . $vars->{VARDB_server} . ":" . $vars->{VARDB_port}, $vars->{VARDB_user}, $vars->{VARDB_pass} )
  or die "Couldn't connect to database: " . DBI->errstr;

### Grab Server values from the database
my $stmtA = "SELECT * FROM servers where server_ip = '" . $vars->{VARserver_ip} . "';";
my $sthA = $dbhA->prepare($stmtA) or die "preparing: ",$dbhA->errstr;
$sthA->execute or die "executing: $stmtA ", $dbhA->errstr;
$server = $sthA->fetchrow_hashref;
$sthA->finish();

# Read AGI vars.
my %aout = $AGI->ReadParse();
agi_output("AGI Environment Dump:");
foreach my $i (sort keys %aout) {
        $AGI->{$i} = $aout{$i};
        agi_output(" -- $i = " . $AGI->{$i});
}


my @digits = split(//, $AGI->{callerid});
@digits = split(//, $AGI->{calleridname}) if ($AGI->{callerid} =~ /unknown/i);

# Send out DTMF for each digit recieved in callerid.
foreach my $dtmf (@digits) {
	$dtmf = "hash" if ($dtmf =~ /\#/);
	$dtmf = "star" if ($dtmf =~ /\*/);
	if ($dtmf eq ',') {
		sleep(1);
	} else {
		$AGI->stream_file("dtmf-" . $dtmf);
	}
        agi_output("DTMF: " . $dtmf);
	usleep(1*100*1000);
}



### Other subroutines.
sub agi_output {
	my ($agi_string,$extinfo) = @_;
	if ($server->{agi_output}) {
		my $date = sql_date();
		$agi_string .= '|' . $AGI->{uniqueid};
		$agi_string .= '|' . $AGI->{CIDlead_id} if ($AGI->{CIDlead_id});
		$agi_string .= '|' . join('|',$AGI->{channel},$AGI->{extension},$AGI->{priority},$AGI->{type},$AGI->{accountcode}) if ($extinfo);
		if ($server->{agi_output} =~ /FILE|BOTH/) {
			### open the log file for writing ###
			open(Lout, ">>" . $vars->{AGILOGFILE}) || die "Can't open " . $vars->{AGILOGFILE} . ": $!\n";
			print Lout "$date|" . $vars->{script} . "|$$|$agi_string\n";
			close(Lout);
		}
		### send to STDERR writing ###
		print STDERR "$date|" . $vars->{script} . "|$$|$agi_string\n" if ($server->{agi_output} =~ /STDERR|FILE/ or $vars->{DB} > 1);
	}
}

sub sql_date {
	my($tms) = @_;
	$tms = time() unless ($tms);
	my ($s,$m,$h,$D,$M,$Y,$wday,$yday,$isdst) = localtime($tms);
	$Y += 1900;
	return sprintf('%.4d-%.2d-%.2d %.2d:%.2d:%.2d', $Y, ++$M, $D, $h, $m, $s);
}


sub getOSDconfig {
        my($AGCpath) = @_;
        my %config;
        $config{PATHconf} = $AGCpath;
        open(CONF, $config{PATHconf}) || die "can't open " . $config{PATHconf} . ": " . $! . "\n";
        while (my $line = <CONF>) {
                $line =~ s/ |>|"|'|\n|\r|\t|\#.*|;.*//gi;
                if ($line =~ /=|:/) {
                        my($key,$val) = split /=|:/, $line;
                        $config{$key} = $val;
                }
        }
        $config{VARDB_port} = '3306' unless ($config{VARDB_port});
        $config{VARFTP_port} = '21' unless ($config{VARFTP_port});
        $config{VARREPORT_port} = '21' unless ($config{VARREPORT_port});
        return \%config;
}

