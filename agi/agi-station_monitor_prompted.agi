#!/usr/bin/perl
#
## Copyright (C) 2009  Lott Caskey  <lottcaskey@gmail.com>    LICENSE: AGPLv3
##
##     This file is part of OSDial.
##
##     OSDial is free software: you can redistribute it and/or modify
##     it under the terms of the GNU Affero General Public License as
##     published by the Free Software Foundation, either version 3 of
##     the License, or (at your option) any later version.
##
##     OSDial is distributed in the hope that it will be useful,
##     but WITHOUT ANY WARRANTY; without even the implied warranty of
##     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##     GNU Affero General Public License for more details.
##
##     You should have received a copy of the GNU Affero General Public
##     License along with OSDial.  If not, see <http://www.gnu.org/licenses/>.
##
# 090519-1925 - Added support for multi-server monitoring.

# default path to osdial configuration file:
$PATHconf =		'/etc/osdial.conf';

open(conf, "$PATHconf") || die "can't open $PATHconf: $!\n";
@conf = <conf>;
close(conf);
$i=0;
foreach(@conf)
	{
	$line = $conf[$i];
	$line =~ s/ |>|\n|\r|\t|\#.*|;.*//gi;
	if ( ($line =~ /^PATHhome/) && ($CLIhome < 1) )
		{$PATHhome = $line;   $PATHhome =~ s/.*=//gi;}
	if ( ($line =~ /^PATHlogs/) && ($CLIlogs < 1) )
		{$PATHlogs = $line;   $PATHlogs =~ s/.*=//gi;}
	if ( ($line =~ /^PATHagi/) && ($CLIagi < 1) )
		{$PATHagi = $line;   $PATHagi =~ s/.*=//gi;}
	if ( ($line =~ /^PATHweb/) && ($CLIweb < 1) )
		{$PATHweb = $line;   $PATHweb =~ s/.*=//gi;}
	if ( ($line =~ /^PATHsounds/) && ($CLIsounds < 1) )
		{$PATHsounds = $line;   $PATHsounds =~ s/.*=//gi;}
	if ( ($line =~ /^PATHmonitor/) && ($CLImonitor < 1) )
		{$PATHmonitor = $line;   $PATHmonitor =~ s/.*=//gi;}
	if ( ($line =~ /^VARserver_ip/) && ($CLIserver_ip < 1) )
		{$VARserver_ip = $line;   $VARserver_ip =~ s/.*=//gi;}
	if ( ($line =~ /^VARDB_server/) && ($CLIDB_server < 1) )
		{$VARDB_server = $line;   $VARDB_server =~ s/.*=//gi;}
	if ( ($line =~ /^VARDB_database/) && ($CLIDB_database < 1) )
		{$VARDB_database = $line;   $VARDB_database =~ s/.*=//gi;}
	if ( ($line =~ /^VARDB_user/) && ($CLIDB_user < 1) )
		{$VARDB_user = $line;   $VARDB_user =~ s/.*=//gi;}
	if ( ($line =~ /^VARDB_pass/) && ($CLIDB_pass < 1) )
		{$VARDB_pass = $line;   $VARDB_pass =~ s/.*=//gi;}
	if ( ($line =~ /^VARDB_port/) && ($CLIDB_port < 1) )
		{$VARDB_port = $line;   $VARDB_port =~ s/.*=//gi;}
	$i++;
	}

if (!$VARDB_port) {$VARDB_port='3306';}

use Asterisk::AGI;
$AGI = new Asterisk::AGI;
use DBI;
  
$dbhA = DBI->connect("DBI:mysql:$VARDB_database:$VARDB_server:$VARDB_port", "$VARDB_user", "$VARDB_pass")
    or die "Couldn't connect to database: " . DBI->errstr;


$|=1;
while(<STDIN>) 
{
	chomp;
	last unless length($_);
	if ($AGILOG)
	{
		if (/^agi_(\w+)\:\s+(.*)$/)
		{
			$AGI{$1} = $2;
		}
	}

	if (/^agi_uniqueid\:\s+(.*)$/)		{$unique_id = $1; $uniqueid = $unique_id;}
	if (/^agi_priority\:\s+(.*)$/)		{$priority = $1;}
	if (/^agi_channel\:\s+(.*)$/)		{$channel = $1;}
	if (/^agi_extension\:\s+(.*)$/)		{$extension = $1;}
	if (/^agi_type\:\s+(.*)$/)		{$type = $1;}
	if (/^agi_callerid\:\s+(.*)$/)		{$callerid = $1;}
	if (/^agi_calleridname\:\s+(.*)$/)	{$calleridname = $1;}
	if (/^agi_accountcode\:\s+(.*)$/)	{$accountcode = $1;}
}

my $campaign_id='';
my $phone_exten='';
$AGI->answer;

my $camp_loop=1;
while ($camp_loop) {
	$camp_loop++;
	exit 1 if ($camp_loop>4);
	$campaign_id = stream_and_get_dtmf('please-enter-the-room-number-you-wish-to-join', 8, 3, 10, 1000, 'BAD', '1234567890', 3, '#');
	if ($campaign_id ne 'BAD') {
		$stmtA = "SELECT count(*) FROM osdial_campaigns WHERE (campaign_id='$campaign_id' OR ('9898'='$campaign_id' AND campaign_id LIKE '%TEST%'));";
		$sthA = $dbhA->prepare($stmtA) or die "preparing: ",$dbhA->errstr;
		$sthA->execute or die "executing: $stmtA ", $dbhA->errstr;
		@aryA = $sthA->fetchrow_array;
		$sthA->finish();
		if ($aryA[0]<1) {
			$AGI->stream_file('invalid-room');
		} else {
			$camp_loop=0;
			my $exten_loop=1;
			while ($exten_loop) {
				$exten_loop++;
				if ($exten_loop>3) {
					$camp_loop=1;
					$exten_loop=0;
				}
				$phone_exten = stream_and_get_dtmf('please-enter-the-extension-2-b-monitored', 8, 3, 10, 1000, 'BAD', '1234567890', 3, '#');
				if ($phone_exten ne 'BAD') {
					$stmtA = "SELECT count(*) FROM phones WHERE (extension='$phone_exten' OR dialplan_number='$phone_exten');";
					$sthA = $dbhA->prepare($stmtA) or die "preparing: ",$dbhA->errstr;
					$sthA->execute or die "executing: $stmtA ", $dbhA->errstr;
					@aryA = $sthA->fetchrow_array;
					$sthA->finish();
					if ($aryA[0]<1) {
						$AGI->stream_file('invalid-extension');
					} else {
						$stmtA = "SELECT ola.conf_exten,s.server_ip,s.server_id FROM osdial_live_agents AS ola,servers AS s,phones where ((phones.extension='$phone_exten' OR phones.dialplan_number='$phone_exten') AND (ola.extension LIKE concat(phones.protocol,'/',phones.extension,'\%') OR ola.extension LIKE concat('\%/',phones.login,'\@\%') OR ola.extension LIKE concat('Local/',phones.dialplan_number,'%'))) AND s.server_ip=ola.server_ip AND phones.server_ip=s.server_ip LIMIT 1;";
						$sthA = $dbhA->prepare($stmtA) or die "preparing: ",$dbhA->errstr;
						$sthA->execute or die "executing: $stmtA ", $dbhA->errstr;
						@aryA = $sthA->fetchrow_array;
						$sthA->finish();

						if ($aryA[0] eq "") {
							$AGI->stream_file('extension');
							$AGI->say_digits($phone_exten);
							$AGI->stream_file('not-yet-connected');
							$AGI->stream_file('check-number-dial-again');
						} else {
							$exten_loop=0;
							$AGI->stream_file('connected');
							my $remDIALstr='';
							if($aryA[1] =~ m/(\S+)\.(\S+)\.(\S+)\.(\S+)/ and $aryA[1] ne $VARserver_ip) {
								$remDIALstr = sprintf('%.3d*%.3d*%.3d*%.3d*',$1,$2,$3,$4);
							}
							$remDIALstr .= '0' . $aryA[0];
							$AGI->exec("Dial",'Local/' . $remDIALstr . '@default');
						}
					}
				}
			}
		}
	}
}

$AGI->hangup;
exit 0;

sub stream_and_get_dtmf {
	my ($stream, $dcount, $rptloops, $waitloops, $waittimeout, $timeout_action, $valid_digits, $min_digits, $exit_digit) = @_;
	return -1 unless ($stream);
	$dcount = 1 unless ($dcount);
	$rptloops = 3 unless ($rptloops);
	$waitloops = 5 unless ($waitloops);
	$waittimeout = 500 unless ($waittimeout);
	$valid_digits = '0123456789#*' unless ($valid_digits);
	$valid_digits .= $exit_digit if ($exit_digit ne '');
	$valid_digits = ''  if ($valid_digits == -1);
	$min_digits = $dcount if ($min_digits eq '');

	my $orig_dcount = $dcount;
	my $rpt = 0;
	my $total_digits;
	$valid_digits =~ s/\*/\\*/g;
	$valid_digits =~ s/\#/\\#/g;
	my $valid_pat = '[^' . $valid_digits . ']';

	while (length($total_digits) < $dcount and $rpt < $rptloops) {
		$total_digits = '';
		$stream =~ s/\....$//;
		my $interrupt_digit = $AGI->stream_file($stream,$valid_digits);
		if ($interrupt_digit) {
			$total_digits=chr($interrupt_digit);
		}

		my $loop = 0;
		while (length($total_digits) < $dcount and $loop < $waitloops) {
			my $digit = $AGI->wait_for_digit($waittimeout);
			if ($digit) {
				$digit = chr($digit);
				$digit =~ s/$valid_pat//g;
				if ($digit ne '') {
					if ($exit_digit ne '' and $exit_digit eq $digit) {
						$dcount = length($total_digits);
						$orig_dcount = length($total_digits);
					} else {
						$total_digits .= $digit;
					}
				}
				$loop=0;
			} else {
				$loop++;
			}
			$loop = $waitloops if (length($total_digits) >= $dcount);
		}

		if (length($total_digits) >= $dcount) {
			$rpt = $rptloops;
		} elsif ($rpt >= $rptloops) {
			$dcount = length($total_digits);
		} else {
			$rpt++;
		}
	}

	if (length($total_digits) != $orig_dcount or length($total_digits) < $min_digits) {
		return $timeout_action;
	} else {
		return $total_digits;
	}
}


