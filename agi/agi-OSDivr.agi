#!/usr/bin/perl
#
# Copyright (C) 2009  Lott Caskey <lottcaskey@gmail.com>   LICENSE: AGPLv3
#
# agi-OSDivr.agi
# 
# This is a rework of the OutboundIVR to make IVR menus both Inbound/Outbound compaitible.
# 
# CHANGELOG
# 090601-1120 - Initial build
#

$|++;

use strict;
use DBI;
use Time::HiRes qw(gettimeofday usleep sleep);
use Asterisk::AGI;

my $AGI = new Asterisk::AGI;
my $vars = {};
my $server = {};
my $auto_calls = {};
my $campaign = {};
my $ivr = {};

$SIG{HUP} = 'exit_now';
$SIG{INT} = 'exit_now';
$SIG{PIPE} = 'exit_now';
$SIG{QUIT} = 'exit_now';

# Get OSD configuration directives.
$vars = getOSDconfig('/etc/osdial.conf');

$vars->{DB} = 3 unless ($vars->{DB});
$vars->{script} = 'agi-OSDivr.agi';


# Grab some time values.
$vars->{start_epoch} = time();
$vars->{start_date} = sql_date($vars->{start_epoch});
$vars->{CIDdate} = substr($vars->{start_date},4);
$vars->{CIDdate} =~ s/\D//g;

$vars->{AGILOGFILE} = $vars->{PATHlogs} . "/agiout." . $vars->{start_date};
$vars->{AGILOGFILE} =~ s/ .*//g;



# Connect to database.
my $dbhA = DBI->connect("DBI:mysql:" . $vars->{VARDB_database} . ":" . $vars->{VARDB_server} . ":" . $vars->{VARDB_port}, $vars->{VARDB_user}, $vars->{VARDB_pass} )
  or die "Couldn't connect to database: " . DBI->errstr;

### Grab Server values from the database
my $stmtA = "SELECT * FROM servers where server_ip = '" . $vars->{VARserver_ip} . "';";
my $sthA = $dbhA->prepare($stmtA) or die "preparing: ",$dbhA->errstr;
$sthA->execute or die "executing: $stmtA ", $dbhA->errstr;
$server = $sthA->fetchrow_hashref;
$sthA->finish();

my %aout = $AGI->ReadParse();
agi_output("AGI Environment Dump:");
foreach my $i (sort keys %aout) {
	$AGI->{$i} = $aout{$i};
	agi_output(" -- $i = " . $AGI->{$i});
}

if ( (length($AGI->{callerid})>20) && ($AGI->{callerid} =~ /\"\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S\S/) ) {
	my $orig = $AGI->{callerid};
	$AGI->{callerid} =~ s/^\"//gi;
	$AGI->{callerid} =~ s/\".*$//gi;
	agi_execute("SET CALLERID " . $AGI->{callerid});
	agi_output("callerID1 changed from '" . $orig . "' to '" . $AGI->{callerid} . "'.");
}
if ( ((length($AGI->{calleridname})>5) && ( (!$AGI->{callerid}) or ($AGI->{callerid} =~ /unknown|private|00000000/i) or ($AGI->{callerid} =~ /5551212/) ))
   or ( (length($AGI->{calleridname})>17) && ($AGI->{calleridname} =~ /\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d/) ) ) {
	$AGI->{callerid} = $AGI->{calleridname};
	agi_execute("SET CALLERID " . $AGI->{callerid});
	agi_output("callerID2 changed from '" . $AGI->{calleridname} . "' to '" . $AGI->{callerid} . "'.");
}
$AGI->{callerid} =~ s/\"//gi;


my $live_agents = {};
my $latry = 5;
while ($latry > 0) {
	$stmtA = "SELECT * FROM osdial_live_agents WHERE callerid='" . $AGI->{callerid} . "' LIMIT 1;";
	$sthA = $dbhA->prepare($stmtA) or die "preparing: ",$dbhA->errstr;
	$sthA->execute or die "executing: $stmtA ", $dbhA->errstr;
	my $larows = $sthA->rows();
	agi_output("$larows|$stmtA|") if ($vars->{DB} > 1);
	if ($larows > 0) {
		$live_agents = $sthA->fetchrow_hashref;
		$latry=0;
	} else {
		sleep 1;
		$latry--;
	}
	$sthA->finish();
}

$AGI->{orig_callerid} = $AGI->{callerid};
$AGI->{orig_channel} = $AGI->{channel};
$AGI->{orig_uniqueid} = $AGI->{uniqueid};
$AGI->{callerid} = $live_agents->{callerid};
$AGI->{channel} = $live_agents->{channel};
$AGI->{uniqueid} = $live_agents->{uniqueid};
$vars->{conf_exten} = $live_agents->{conf_exten};
my @scsip = split(/\./,$live_agents->{server_ip});
my $csip = sprintf('%3.3d*%3.3d*%3.3d*%3.3d', @scsip);
$vars->{conf_server} = $csip;


my $stmtA = "UPDATE osdial_live_agents SET channel='" . $AGI->{orig_channel} . "',status='INCALL',last_call_time='" . $vars->{start_date} . "' WHERE callerid='" . $AGI->{callerid} . "' LIMIT 1;";
my $affected_rows = $dbhA->do($stmtA);
my $stmtA = "UPDATE osdial_auto_calls SET channel='" . $AGI->{orig_channel} . "' WHERE callerid='" . $AGI->{callerid} . "' LIMIT 1;";
my $affected_rows = $dbhA->do($stmtA);

$vars->{CIDlead_id} = (substr($AGI->{callerid}, 11, 9) + 0);

agi_output("+++++ ODOI START : " . $server->{asterisk_version},1);


my ($affected_rows, $safe_harbor_message, $safe_harbor_exten);

### Grab call parameters from osdial_auto_calls table
	$stmtA = "SELECT * FROM osdial_auto_calls where callerid='" . $AGI->{callerid} . "' order by call_time desc limit 1;";
	agi_output("|$stmtA|") if ($vars->{DB} > 1);
	$sthA = $dbhA->prepare($stmtA) or die "preparing: ",$dbhA->errstr;
	$sthA->execute or die "executing: $stmtA ", $dbhA->errstr;
	$auto_calls = $sthA->fetchrow_hashref;
	$sthA->finish();

	### Grab campaign values from the database
	$stmtA = "SELECT * FROM osdial_campaigns where campaign_id = '" . $live_agents->{campaign_id} . "';";
	agi_output("|$stmtA|") if ($vars->{DB} > 1);
	$sthA = $dbhA->prepare($stmtA) or die "preparing: ",$dbhA->errstr;
	$sthA->execute or die "executing: $stmtA ", $dbhA->errstr;
	$campaign = $sthA->fetchrow_hashref;
	$sthA->finish();

update_status($dbhA,'VPU',$ivr->{announcement});


# Pull the auto-agent ivr config.
my $stmtA = "SELECT * FROM osdial_ivr WHERE campaign_id='" . $campaign->{campaign_id} . "';";
agi_output("|$stmtA|") if ($vars->{DB} > 1);
my $sthA = $dbhA->prepare($stmtA) or die "preparing: ",$dbhA->errstr;
$sthA->execute or die "executing: $stmtA ", $dbhA->errstr;
$ivr = $sthA->fetchrow_hashref;
$sthA->finish();
unless ($ivr) {
	agi_output("+++++ ODOI : NO OUTBOUND IVR FOUND FOR THIS CAMPAIGN: EXITING");
	exit;
}


$ivr->{ivrid} = $ivr->{id};
$ivr->{parid} = 0;
ivr_menu($ivr);

exit_now();






################################################################

sub exit_now {
	my($sig) = @_;
	$SIG{HUP} = 'IGNORE';
	$SIG{INT} = 'IGNORE';
	$SIG{PIPE} = 'IGNORE';
	$SIG{QUIT} = 'IGNORE';
	hangup_and_dispo();
	agi_output("--    ODOI END - $sig");
	$dbhA->disconnect();
	$AGI->hangup();
	exit;
}


sub ivr_menu {
	my ($menuref) = @_;
	my $ivrloop = 1;
	my %menu = %{$menuref};
	agi_output("+++++ ODOI MENU : " . $menu{ivrid} . "/" . $menu{parid});
	update_status($dbhA,$menu{answered_status},$menu{announcement});
	while ($ivrloop) {
		# Get valid-digits from options table.
		my $valid_digits;
		my $stmtA = "SELECT * FROM osdial_ivr_options WHERE ivr_id='" . $menu{ivrid} . "' AND parent_id='" . $menu{parid} . "';";
		agi_output("|$stmtA|") if ($vars->{DB} > 1);
		my $sthA = $dbhA->prepare($stmtA) or die "preparing: ",$dbhA->errstr;
		$sthA->execute or die "executing: $stmtA ", $dbhA->errstr;
		while (my $ivrref = $sthA->fetchrow_hashref) {
			my $dkey = 'key' . $ivrref->{keypress};
			$menu{$dkey} = $ivrref; 
			$valid_digits .= $ivrref->{keypress};
		}
		$sthA->finish();
		agi_output("+++++ ODOI VALID DIGITS : $valid_digits");
	
		my $dtmf = stream_and_get_dtmf("ivr/" . $menu{announcement},1,$menu{repeat_loops},$menu{wait_loops},$menu{wait_timeout},$menu{timeout_action},$valid_digits);
		agi_output("+++++ ODOI STATUS : pressed $dtmf");
	
		my $dkey = "key" . $dtmf;
		my @aparams = split(/#:#/,$menu{$dkey}{action_data});
	
		if ($menu{$dkey}{action} eq "PLAYFILE") {
			$ivrloop = playfile(@aparams);
		} elsif ($menu{$dkey}{action} eq "XFER_EXTERNAL") {
			$ivrloop = xfer_to_external(@aparams);
		} elsif ($menu{$dkey}{action} eq "XFER_EXTERNAL_MULTI") {
			$ivrloop = xfer_to_external_multi($menu{$dkey}{id}, $menu{$dkey}{last_state}, @aparams);
		} elsif ($menu{$dkey}{action} eq "XFER_AGENT") {
			$ivrloop = xfer_to_agent(@aparams);
		} elsif ($menu{$dkey}{action} eq "XFER_INGROUP") {
			$ivrloop = xfer_to_ingroup(@aparams);
		} elsif ($menu{$dkey}{action} eq "HANGUP") {
			$ivrloop = hangup_and_dispo(@aparams);
		} elsif ($menu{$dkey}{action} eq "TVC_LOOKUP") {
			$ivrloop = tvc_lookup_xfer(@aparams);
		} elsif ($menu{$dkey}{action} eq "MENU") {
			my $submenuref = {};
			$submenuref->{ivrid} = $menu{ivrid};
			$submenuref->{parid} = $menu{$dkey}{id};
			shift @aparams;
			shift @aparams;
			$submenuref->{announcement} = shift @aparams;
			$submenuref->{repeat_loops} = shift @aparams;
			$submenuref->{wait_loops} = shift @aparams;
			$submenuref->{wait_timeout} = shift @aparams;
			$submenuref->{answered_status} = shift @aparams;
			$submenuref->{timeout_action} = shift @aparams;
			$ivrloop = ivr_menu($submenuref);
		} elsif ($menu{$dkey}{action} eq "MENU_REPEAT") {
			$ivrloop = 1;
		} elsif ($menu{$dkey}{action} eq "MENU_EXIT") {
			$ivrloop = 0;
		} else {
			$ivrloop = 0;
		}
		update_status($dbhA);
	}
	return $ivrloop;
}



sub update_status {
	my ($dbh, $status, $comment) = @_;

	my $upsql;
	$upsql = "status='$status'" if ($status ne '');
	$upsql = "comment='$comment'" if ($comment ne '');
	$upsql = "status='$status',comments='$comment'" if ($status ne '' and $comment ne '');

	if ($status or $comment) {
		my $stmtA = "UPDATE osdial_list set $upsql where lead_id='" . $vars->{CIDlead_id} . "';";
		my $affected_rows = $dbh->do($stmtA);
		agi_output("--    ODOI osdial_list update: |$affected_rows|" . $upsql);

		$stmtA = "UPDATE osdial_log set $upsql where uniqueid='" . $AGI->{uniqueid} . "';";
		$affected_rows = $dbh->do($stmtA);
		if ($affected_rows < 1) {
			$stmtA = "UPDATE osdial_closer_log set $upsql where uniqueid='" . $AGI->{uniqueid} . "';";
			$affected_rows = $dbh->do($stmtA);
			agi_output("--    ODOI osdial_closer_log update: |$affected_rows");
		} else {
			agi_output("--    ODOI osdial_log update: |$affected_rows");
		}
	}

	my $xepoch = time();
	my $xdate = sql_date($xepoch);
	my $stmtA = "UPDATE osdial_auto_calls set last_update_time='$xdate' where channel LIKE '%" . $vars->{conf_exten} . "%';";
	my $affected_rows = $dbh->do($stmtA);
	return 1;
}

sub playfile {
	my ($stream, $status, $rtnmain) = @_;

	update_status($dbhA,$status);
	$stream =~ s/\....$//;
	$AGI->stream_file('ivr/' . $stream);

	return $rtnmain;
}

sub xfer_to_external {
	my ($stream, $status, $number) = @_;

	$stream =~ s/\....$//;
	$AGI->stream_file('ivr/' . $stream) if ($stream);

	update_status($dbhA,$status);

	my $xepoch = time();
	my $xdate = sql_date($xepoch);
	my $call_length = $xepoch - $vars->{start_time};

	agi_output("ODOI: transferring call to $number|" . $vars->{conf_exten});
	my $VqueryCID = $AGI->{callerid};
	my $XqueryCID = $VqueryCID;
	$XqueryCID =~ s/^V/X/;
	my $IqueryCID = $VqueryCID;
	$IqueryCID =~ s/^V/I/;
	#$stmtA="INSERT INTO osdial_manager values('','','$xdate','NEW','N','" . $vars->{VARserver_ip} . "','','Originate','$XqueryCID','Channel: Local/8" . $vars->{conf_exten} . "\@" . $server->{ext_context} . "','Context: " . $server->{ext_context} . "','Exten: $number','Priority: 1','Callerid: \"$XqueryCID\" <" . $campaign->{campaign_cid} . ">','','','','','');";
	$stmtA="INSERT INTO osdial_manager values('','','$xdate','NEW','N','" . $vars->{VARserver_ip} . "','','Originate','$XqueryCID','Channel: Local/" . $vars->{conf_server} . "*8" . $vars->{conf_exten} . "\@" . $server->{ext_context} . "','Context: " . $server->{ext_context} . "','Exten: $number','Priority: 1','Callerid: \"$XqueryCID\" <" . $campaign->{campaign_cid} . ">','','','','','');";
	my $xfer = $dbhA->do($stmtA);
	while ($xfer) {
		sleep(1);
		my $stmtA = "SELECT count(*) FROM osdial_manager where (callerid='$XqueryCID' OR callerid='$IqueryCID') AND status='DEAD';";
		my $sthA = $dbhA->prepare($stmtA) or die "preparing: ",$dbhA->errstr;
		$sthA->execute or die "executing: $stmtA ", $dbhA->errstr;
		my @aryA = $sthA->fetchrow_array;
		$sthA->finish();
		$xfer=0 if ($aryA[0] == 1);
		my $stmtA = "SELECT count(*) FROM live_sip_channels WHERE server_ip='" . $vars->{VARserver_ip} . "' AND extension='" . $vars->{conf_exten} . "' order by channel desc;";
		my $sthA = $dbhA->prepare($stmtA) or die "preparing: ",$dbhA->errstr;
		$sthA->execute or die "executing: $stmtA ", $dbhA->errstr;
		my @aryA = $sthA->fetchrow_array;
		$xfer = 0 if ($aryA[0] == 0);
		$sthA->finish();
		agi_output("ODOI: $xfer|$stmtA") if ($vars->{DB} > 1);

		my $xepoch = time();
		my $xdate = sql_date($xepoch);
		my $stmtA = "UPDATE osdial_auto_calls set last_update_time='$xdate' where channel LIKE '%" . $vars->{conf_exten} . "%';";
		my $affected_rows = $dbhA->do($stmtA);
	}
	agi_output("exiting the ODOI app");

	# The call should be well on its way to being transferred
	return 0;
}

sub xfer_to_external_multi {
	my ($ivro_id, $last_state, $stream, $status, $method, @numbers) = @_;
	
	# stream and status will get handled when passed to xfer_to_external.
	my $number;

	if ($method eq "RANDOM") {
		# Grab a random number from the stack.
		$number = $numbers[int(rand(scalar(@numbers)))];
	} else {
		# Round-Robin.
		my %robin;
		my $pos = 0;
		my $rrcnt = 0;
		foreach my $num (@numbers) {
			$robin{$num} = $rrcnt++;
		}
		$pos = $robin{$last_state} if ($last_state);
		$pos++;
		$pos = 0 if ($pos >= $rrcnt);
		$number = $numbers[$pos];

		my $stmtA =  "UPDATE osdial_ivr_options SET last_state='$number' WHERE id='$ivro_id';";
		agi_output("|$stmtA|$pos|$rrcnt") if ($vars->{DB} > 1);
		my $affected_rows = $dbhA->do($stmtA);
	}
	return xfer_to_external($stream, $status, $number);
}

# Depricated, to be replaced by xfer_to_ingroup
sub xfer_to_agent {
	return 1;
}
# The new xfer_to_ingroup
# For transfering to an ingroup.
#   If failover_method = NONE or ''
#     The call routed directly to the ingroup.
#   If failover_method = EXT_NA
#     The call routed directly to the failover_number if no agents in ingroup are present.
#   If failover_method = EXT_UA
#     The call routed directly to the failover_number if no agents in ingroup are present or available.
sub xfer_to_ingroup {
	my ($stream, $status, $ingroup, $failover_method, $failover_number) = @_;

	$stream =~ s/\....$//;
	$AGI->stream_file('ivr/' . $stream) if ($stream);

	update_status($dbhA,$status);


	my $xepoch = time();
	my $xdate = sql_date($xepoch);
	my $call_length = $xepoch - $vars->{start_time};

    my $number = '';;
    if ($failover_method eq 'EXT_NA') {
        my $stmtA = "SELECT count(*) FROM osdial_live_agents WHERE closer_campaigns LIKE '% $ingroup %';";
		my $sthA = $dbhA->prepare($stmtA) or die "preparing: ",$dbhA->errstr;
		$sthA->execute or die "executing: $stmtA ", $dbhA->errstr;
		my @aryA = $sthA->fetchrow_array;
		$sthA->finish();
        if ($aryA[0] < 1) {
            # no agents logged in, send to failover_number
            $number = $failover_number;
        }
    } elsif ($failover_method eq 'EXT_UA') {
        my $stmtA = "SELECT count(*) FROM osdial_live_agents WHERE closer_campaigns LIKE '% $ingroup %' AND uniqueid<'1';";
		my $sthA = $dbhA->prepare($stmtA) or die "preparing: ",$dbhA->errstr;
		$sthA->execute or die "executing: $stmtA ", $dbhA->errstr;
		my @aryA = $sthA->fetchrow_array;
		$sthA->finish();
        if ($aryA[0] < 1) {
            # no agents logged in or they are unavailable, send to failover_number
            $number = $failover_number;
        }
    }
    if ($number eq '') {
        $number = "90009*" . $ingroup . "*8301*" . $vars->{CIDlead_id} . "*park***";
    }

	agi_output("ODOI: transferring call to $number|" . $vars->{conf_exten});
	my $VqueryCID = $AGI->{callerid};
	my $XqueryCID = $VqueryCID;
	$XqueryCID =~ s/^V/I/;
	#my $stmtA="INSERT INTO osdial_manager values('','','$xdate','NEW','N','" . $vars->{VARserver_ip} . "','','Originate','$XqueryCID','Channel: Local/8" . $vars->{conf_exten} . "\@" . $server->{ext_context} . "','Context: " . $server->{ext_context} . "','Exten: $number','Priority: 1','Callerid: \"$XqueryCID\" <" . $campaign->{campaign_cid} . ">','','','','','');";
	my $stmtA="INSERT INTO osdial_manager values('','','$xdate','NEW','N','" . $vars->{VARserver_ip} . "','','Originate','$XqueryCID','Channel: Local/" . $vars->{conf_server} . "*8" . $vars->{conf_exten} . "\@" . $server->{ext_context} . "','Context: " . $server->{ext_context} . "','Exten: $number','Priority: 1','Callerid: \"$XqueryCID\" <" . $campaign->{campaign_cid} . ">','','','','','');";
	my $xfer = $dbhA->do($stmtA);
	while ($xfer) {
		sleep(1);
		my $stmtA = "SELECT count(*) FROM osdial_manager where callerid='$XqueryCID' AND status='DEAD';";
		my $sthA = $dbhA->prepare($stmtA) or die "preparing: ",$dbhA->errstr;
		$sthA->execute or die "executing: $stmtA ", $dbhA->errstr;
		my @aryA = $sthA->fetchrow_array;
		$sthA->finish();
		$xfer=0 if ($aryA[0] == 1);
		my $stmtA = "SELECT count(*) FROM live_sip_channels WHERE server_ip='" . $vars->{VARserver_ip} . "' AND extension LIKE '%" . $vars->{conf_exten} . "%' order by channel desc;";
		my $sthA = $dbhA->prepare($stmtA) or die "preparing: ",$dbhA->errstr;
		$sthA->execute or die "executing: $stmtA ", $dbhA->errstr;
		my @aryA = $sthA->fetchrow_array;
		$xfer = 0 if ($aryA[0] == 0);
		$sthA->finish();
		agi_output("ODOI: $xfer|$stmtA") if ($vars->{DB} > 1);

		my $xepoch = time();
		my $xdate = sql_date($xepoch);
		my $stmtA = "UPDATE osdial_auto_calls set last_update_time='$xdate' where channel LIKE '%" . $vars->{conf_exten} . "%';";
		my $affected_rows = $dbhA->do($stmtA);
	}
	agi_output("exiting the ODOI xfer_to_ingroup");

	# The call should be well on its way to being transferred
	return 0;
}



sub hangup_and_dispo {
	my ($stream, $status) = @_;;

	$stream =~ s/\....$//;
	$AGI->stream_file('ivr/' . $stream) if ($stream);

	my $tepoch = time();
	my $tdate = sql_date($tepoch);
	my $call_length = $tepoch - $vars->{start_time};

	my $dbhB = DBI->connect("DBI:mysql:" . $vars->{VARDB_database} . ":" . $vars->{VARDB_server} . ":" . $vars->{VARDB_port}, $vars->{VARDB_user}, $vars->{VARDB_pass} )
	  or warn "Couldn't connect to database: " . DBI->errstr;

	if ($status eq 'DNC' or $status eq 'VDNC') {
		my $stmtA = "INSERT INTO osdial_dnc VALUES ((SELECT phone_number FROM osdial_list WHERE lead_id='" . $vars->{CIDlead_id} ."'));";
		agi_output("|$stmtA|") if ($vars->{DB} > 1);
		my $affected_rows = $dbhB->do($stmtA);
		agi_output("--    ODOI osdial_dnc insert: |$affected_rows");
	}

	update_status($dbhB,$status);

	### insert a NEW Hangup record to the osdial_manager table to be processed
	my $VHqueryCID = $AGI->{orig_callerid};
	#my $stmtA = "INSERT INTO osdial_manager values('','','$tdate','NEW','N','" . $vars->{VARserver_ip} . "','','Hangup','$VHqueryCID','Channel: " . $AGI->{channel} . "','','','','','','','','','')";
	#my $affected_rows = $dbhB->do($stmtA);
	#agi_output("$affected_rows|$stmtA|") if ($vars->{DB} > 1);
	#my $stmtA = "INSERT INTO osdial_manager values('','','$tdate','NEW','N','" . $vars->{VARserver_ip} . "','','Hangup','$VHqueryCID','Channel: " . $AGI->{orig_channel} . "','','','','','','','','','')";
	#my $affected_rows = $dbhB->do($stmtA);
	#agi_output("$affected_rows|$stmtA|") if ($vars->{DB} > 1);

	#my $lccnt = 2;
	#my $try = 2;
	## Loop through open channels sleep untill all are closed.
	#while ($lccnt > 1 or $try > 1) {
		my @huchan;
		# Get local channels (conferences)
		my $stmtA = "SELECT channel FROM live_sip_channels WHERE server_ip='" . $vars->{VARserver_ip} . "' AND channel LIKE '%" . $vars->{conf_exten} . "%' order by channel desc;";
		my $sthA = $dbhB->prepare($stmtA) or die "preparing: ",$dbhB->errstr;
		$sthA->execute or die "executing: $stmtA ", $dbhB->errstr;
		while (my @aryA = $sthA->fetchrow_array) {
			push @huchan, $aryA[0];
		}
		$sthA->finish();

		# Get outbound channels attached to those conferences.
		my $stmtA = "SELECT channel FROM live_channels WHERE server_ip='" . $vars->{VARserver_ip} . "' AND extension = '" . $vars->{conf_exten} . "' order by channel desc;";
		my $sthA = $dbhB->prepare($stmtA) or die "preparing: ",$dbhB->errstr;
		$sthA->execute or die "executing: $stmtA ", $dbhB->errstr;
		while (my @aryA = $sthA->fetchrow_array) {
			push @huchan, $aryA[0];
		}
		$sthA->finish();
		# Send hangups to all conferences and outbound channels.
		foreach my $huc (@huchan) {
			my $stmtA = "INSERT INTO osdial_manager values('','','$tdate','NEW','N','" . $vars->{VARserver_ip} . "','','Hangup','$VHqueryCID','Channel: " . $huc . "','','','','','','','','','')";
			my $affected_rows = $dbhB->do($stmtA);
			agi_output("$affected_rows|$stmtA|") if ($vars->{DB} > 1);
		}
	#	sleep 1;

	#	# Get count of local channels still open.
	#	my $stmtA = "SELECT count(*) FROM live_sip_channels WHERE server_ip='" . $vars->{VARserver_ip} . "' AND channel LIKE 'Local/" . $vars->{conf_exten} . "%' order by channel desc;";
	#	agi_output("$affected_rows|$stmtA|") if ($vars->{DB} > 1);
	#	my $sthA = $dbhB->prepare($stmtA) or die "preparing: ",$dbhB->errstr;
	#	$sthA->execute or die "executing: $stmtA ", $dbhB->errstr;
	#	my @aryA = $sthA->fetchrow_array;
	#	$lccnt = $aryA[0];
	#	$sthA->finish();

	#	# Get count of outbound channels still open
	#	my $stmtA = "SELECT count(*) FROM live_channels WHERE server_ip='" . $vars->{VARserver_ip} . "' AND extension = '" . $vars->{conf_exten} . "' order by channel desc;";
	#	agi_output("$affected_rows|$stmtA|") if ($vars->{DB} > 1);
	#	my $sthA = $dbhB->prepare($stmtA) or die "preparing: ",$dbhB->errstr;
	#	$sthA->execute or die "executing: $stmtA ", $dbhB->errstr;
	#	my @aryA = $sthA->fetchrow_array;
	#	$lccnt += $aryA[0];
	#	$sthA->finish();
	#	$try--;
	#}


	my $stmtA = "UPDATE osdial_log set end_epoch='$tepoch' where uniqueid = '" . $AGI->{uniqueid} . "';";
	agi_output("|$stmtA|") if ($vars->{DB} > 1);
	my $affected_rows = $dbhB->do($stmtA);
	my $stmtA = "UPDATE osdial_log set length_in_sec=end_epoch-start_epoch where uniqueid = '" . $AGI->{uniqueid} . "';";
	agi_output("|$stmtA|") if ($vars->{DB} > 1);
	my $affected_rows = $dbhB->do($stmtA);
	agi_output("--    ODOI osdial_log update: $affected_rows");
	my $random = int( rand(9999999)) + 10000000;
	my $stmtA = "UPDATE osdial_live_agents set status='READY',random_id='$random', last_call_finish='$tdate',last_update_time='$tdate',lead_id='',uniqueid='',callerid='',channel='' where conf_exten='" . $vars->{conf_exten} . "' and server_ip='" . $vars->{VARserver_ip} . "';";
	my $affected_rows = $dbhB->do($stmtA);
	agi_output("--    ODOI osdial_live_agents update: $affected_rows");

	$dbhB->disconnect();
	return 0;
}


#Special lookup from db for TVC
sub tvc_lookup_xfer {
	my ($desc, $status, $stream1, $stream2, $ingroup, $tdbserver, $tdbdatabase, $tdbuser, $tdbpass, $tdbtable, $tdbmaps) = @_;

	return 0 if ($tdbtable eq "" or $tdbmaps eq "");
	$tdbmaps =~ s/ //g;
	my %tmaps;
	my @tflds;
	foreach my $tmap (split(/,/,$tdbmaps)) {
		my @tamap = split(/=/,$tmap);
		$tmaps{$tamap[0]} = $tamap[1];
		if ($tamap[1] =~ /\|/) {
			push @tflds, split(/\|/,$tamap[1]);
		} else {
			push @tflds, $tamap[1];
		}
	}

	agi_output("|tvclookup|playback on $stream1|") if ($vars->{DB});
	my $s1res = stream_and_get_dtmf("ivr/" . $stream1, 10, 3, 10, 1000, 'BAD', '1234567890', 10, '');
	agi_output("|tvclookup|got $s1res|") if ($vars->{DB});
	return 0 if ($s1res eq "BAD");

	agi_output("|tvclookup|playback on $stream2|") if ($vars->{DB});
	my $s2res = stream_and_get_dtmf("ivr/" . $stream2, 6, 3, 10, 1000, 'BAD', '01234567890', 2, '#');
	agi_output("|tvclookup|got $s2res|") if ($vars->{DB});
	return 0 if ($s2res eq "BAD");

	my $dbhC = DBI->connect("DBI:mysql:" . $tdbdatabase . ":" . $tdbserver . ":3306", $tdbuser, $tdbpass )
	  or die "Couldn't connect to database: " . DBI->errstr;

	my $stmtC = "SELECT " . join(',', @tflds) . " FROM $tdbtable WHERE " . $tmaps{'phone_number'} . "='" . $s1res . "' limit 1;";
	my $sthC = $dbhC->prepare($stmtC) or die "preparing: ",$dbhC->errstr;
	$sthC->execute or die "executing: $stmtC ", $dbhC->errstr;
	my $qhr = $sthC->fetchrow_hashref;

	foreach my $fld ( keys %{$qhr} ) {
		$qhr->{$fld} =~ s/'"//g;
		agi_output("|tvclookup|$fld|" . $qhr->{$fld}) if ($vars->{DB});
	}
	my $stmtA = "UPDATE osdial_list SET custom1='" . $s2res . "',";
	foreach my $tkey (keys %tmaps) {
		$stmtA .= $tkey . "='";
		if ($tmaps{$tkey} =~ /\|/) {
			foreach my $tconcat (split(/\|/,$tmaps{$tkey})) {
				$stmtA .= $tconcat . '=' .$qhr->{$tconcat} . "||";
			}
		} else {
			$stmtA .= $qhr->{$tmaps{$tkey}};
		}
		$stmtA .= "',";
	}
	chop($stmtA);
	$stmtA .= " WHERE lead_id='" . $vars->{CIDlead_id} . "';";
	my $affected_rows = $dbhA->do($stmtA);
	agi_output("|$stmtA|$affected_rows|") if ($vars->{DB} > 1);

	$dbhC->disconnect;

	return xfer_to_ingroup(0, $status, $ingroup, 'NONE', 0);
}

sub stream_and_get_dtmf {
	my ($stream, $dcount, $rptloops, $waitloops, $waittimeout, $timeout_action, $valid_digits, $min_digits, $exit_digit) = @_;
	return -1 unless ($stream);
	$dcount = 1 unless ($dcount);
	$rptloops = 3 unless ($rptloops);
	$waitloops = 5 unless ($waitloops);
	$waittimeout = 500 unless ($waittimeout);
	$valid_digits = '0123456789#*' unless ($valid_digits);
	$valid_digits .= $exit_digit if ($exit_digit ne '');
	$valid_digits = ''  if ($valid_digits == -1);
	$min_digits = $dcount if ($min_digits eq '');

	my $orig_dcount = $dcount;
	my $rpt = 0;
	my $total_digits;
	$valid_digits =~ s/\*/\\*/g;
	$valid_digits =~ s/\#/\\#/g;
	my $valid_pat = '[^' . $valid_digits . ']';

	agi_output("stream_and_get_dtmf|$stream|$dcount|$rptloops|$waitloops|$waittimeout|$timeout_action|$valid_digits|$min_digits|$exit_digit|") if ($vars->{DB});

	while (length($total_digits) < $dcount and $rpt < $rptloops) {

		my $dbhB = DBI->connect("DBI:mysql:" . $vars->{VARDB_database} . ":" . $vars->{VARDB_server} . ":" . $vars->{VARDB_port}, $vars->{VARDB_user}, $vars->{VARDB_pass} )
		  or warn "Couldn't connect to database: " . DBI->errstr;
		update_status($dbhB);
		$dbhB->disconnect();

		$total_digits = '';
		$stream =~ s/\....$//;
		my $interrupt_digit = $AGI->stream_file($stream,$valid_digits);
		if ($interrupt_digit) {
			agi_output("int_digit |" . chr($interrupt_digit) . "|   total_digits |$total_digits|") if ($vars->{DB});
			$total_digits=chr($interrupt_digit);
		}

		my $loop = 0;
		while (length($total_digits) < $dcount and $loop < $waitloops) {
			my $digit = $AGI->wait_for_digit($waittimeout);
			if ($digit) {
				$digit = chr($digit);
				$digit =~ s/$valid_pat//g;
				if ($digit ne '') {
					agi_output("    digit |$digit|   total_digits |$total_digits|") if ($vars->{DB});
					if ($exit_digit ne '' and $exit_digit eq $digit) {
						$dcount = length($total_digits);
						$orig_dcount = length($total_digits);
					} else {
						$total_digits .= $digit;
					}
				}
				$loop=0;
			} else {
				$loop++;
			}
			$loop = $waitloops if (length($total_digits) >= $dcount);
		}

		if (length($total_digits) >= $dcount) {
			$rpt = $rptloops;
		} elsif ($rpt >= $rptloops) {
			$dcount = length($total_digits);
		} else {
			$rpt++;
		}
	}

	if (length($total_digits) != $orig_dcount or length($total_digits) < $min_digits) {
		return $timeout_action;
	} else {
		return $total_digits;
	}
}




sub agi_execute {
	my ($cmd) = @_;
	my $res = $AGI->execute($cmd);
	if ($res) {
		return $res;
	} else {
		print STDERR "FAIL (unexpected result '$res')\n";
		return -1;
	}
}
	

sub agi_output {
	my ($agi_string,$extinfo) = @_;
	if ($server->{agi_output}) {
		my $date = sql_date();
		$agi_string .= '|' . $AGI->{uniqueid};
		$agi_string .= '|' . $vars->{CIDlead_id};
		$agi_string .= '|' . join('|',$AGI->{channel},$AGI->{extension},$AGI->{priority},$AGI->{type},$AGI->{callerid}) if ($extinfo);

		if ($server->{agi_output} =~ /FILE|BOTH/) {
			### open the log file for writing ###
			open(Lout, ">>" . $vars->{AGILOGFILE}) || die "Can't open " . $vars->{AGILOGFILE} . ": $!\n";
			print Lout "$date|" . $vars->{script} . "|$$|$agi_string\n";
			close(Lout);
		}
		### send to STDERR writing ###
		print STDERR "$date|" . $vars->{script} . "|$$|$agi_string\n" if ($server->{agi_output} =~ /STDERR|FILE/ or $vars->{DB} > 1);
	}
}

sub sql_date {
	my($tms) = @_;
	$tms = time() unless ($tms);
	my ($s,$m,$h,$D,$M,$Y,$wday,$yday,$isdst) = localtime($tms);
	$Y += 1900;
	return sprintf('%.4d-%.2d-%.2d %.2d:%.2d:%.2d', $Y, ++$M, $D, $h, $m, $s);
}


sub getOSDconfig {
	my($AGCpath) = @_;
	my %config;
	$config{PATHconf} = $AGCpath;
	open(CONF, $config{PATHconf}) || die "can't open " . $config{PATHconf} . ": " . $! . "\n";
	while (my $line = <CONF>) {
		$line =~ s/ |>|"|'|\n|\r|\t|\#.*|;.*//gi;
		if ($line =~ /=|:/) {
			my($key,$val) = split /=|:/, $line;
			$config{$key} = $val;
		}
	}
	$config{VARDB_port} = '3306' unless ($config{VARDB_port});
	$config{VARFTP_port} = '21' unless ($config{VARFTP_port});
	$config{VARREPORT_port} = '21' unless ($config{VARREPORT_port});
	return \%config;
}
